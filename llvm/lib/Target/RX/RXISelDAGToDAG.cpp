//===-- RXISelDAGToDAG.cpp - A dag to dag inst selector for RX ------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the RX target.
//
//===----------------------------------------------------------------------===//

#include "RX.h"
#include "MCTargetDesc/RXMCTargetDesc.h"
#include "RXTargetMachine.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#define DEBUG_TYPE "rx-isel"

// RX-specific code to select RX machine instructions for
// SelectionDAG operations.
namespace {
class RXDAGToDAGISel final : public SelectionDAGISel {
  const RXSubtarget *Subtarget;

public:
  explicit RXDAGToDAGISel(RXTargetMachine &TargetMachine)
      : SelectionDAGISel(TargetMachine) {}

  StringRef getPassName() const override {
    return "RX DAG->DAG Pattern Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<RXSubtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  void PostprocessISelDAG() override;

  void Select(SDNode *Node) override;

  bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
                                    std::vector<SDValue> &OutOps) override;

  bool SelectAddrFI(SDValue Addr, SDValue &Base);

// Include the pieces autogenerated from the target description.
#include "RXGenDAGISel.inc"

private:
  void doPeepholeLoadStoreADDI();
  void doPeepholeBuildPairF64SplitF64();
};
}

void RXDAGToDAGISel::PostprocessISelDAG() {
  doPeepholeLoadStoreADDI();
  doPeepholeBuildPairF64SplitF64();
}

void RXDAGToDAGISel::Select(SDNode *Node) {
  unsigned Opcode = Node->getOpcode();
  MVT XLenVT = Subtarget->getXLenVT();

  // If we have a custom node, we have already selected
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  // Instruction Selection not handled by the auto-generated tablegen selection
  // should be handled here.
  EVT VT = Node->getValueType(0);
  if (Opcode == ISD::Constant && VT == XLenVT) {
    auto *ConstNode = cast<ConstantSDNode>(Node);
    // Materialize zero constants as copies from R0. This allows the coalescer
    // to propagate these into other instructions.
    if (ConstNode->isNullValue()) {
      SDValue New = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), SDLoc(Node),
                                           RX::R0, XLenVT);
      ReplaceNode(Node, New.getNode());
      return;
    }
  }
  
  if (Opcode == ISD::FrameIndex) {
    SDLoc DL(Node);
    SDValue Imm = CurDAG->getTargetConstant(0, DL, XLenVT);
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    EVT VT = Node->getValueType(0);
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
    ReplaceNode(Node, CurDAG->getMachineNode(RX::ADD, DL, VT, TFI, Imm));
    return;
  }

  // Select the default instruction.
  SelectCode(Node);
}

bool RXDAGToDAGISel::SelectInlineAsmMemoryOperand(
    const SDValue &Op, unsigned ConstraintID, std::vector<SDValue> &OutOps) {
  switch (ConstraintID) {
  case InlineAsm::Constraint_i:
  case InlineAsm::Constraint_m:
    // We just support simple memory operands that have a single address
    // operand and need no special handling.
    OutOps.push_back(Op);
    return false;
  default:
    break;
  }

  return true;
}

bool RXDAGToDAGISel::SelectAddrFI(SDValue Addr, SDValue &Base) {
  if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), Subtarget->getXLenVT());
    return true;
  }
  return false;
}

// Merge an ADDI into the offset of a load/store instruction where possible.
// (load (add base, off), 0) -> (load base, off)
// (store val, (add base, off)) -> (store val, base, off)
void RXDAGToDAGISel::doPeepholeLoadStoreADDI() {
  SelectionDAG::allnodes_iterator Position(CurDAG->getRoot().getNode());
  ++Position;

  while (Position != CurDAG->allnodes_begin()) {
    SDNode *N = &*--Position;
    // Skip dead nodes and any non-machine opcodes.
    if (N->use_empty() || !N->isMachineOpcode())
      continue;

    int OffsetOpIdx;
    int BaseOpIdx;

    continue;

    // // Only attempt this optimisation for I-type loads and S-type stores.
    // switch (N->getMachineOpcode()) {
    // default:
    //   continue;
    // case RX::LB:
    // case RX::LH:
    // case RX::LW:
    // case RX::LBU:
    // case RX::LHU:
    // case RX::LWU:
    // case RX::LD:
    // case RX::FLW:
    // case RX::FLD:
    //   BaseOpIdx = 0;
    //   OffsetOpIdx = 1;
    //   break;
    // case RX::SB:
    // case RX::SH:
    // case RX::SW:
    // case RX::SD:
    // case RX::FSW:
    // case RX::FSD:
    //   BaseOpIdx = 1;
    //   OffsetOpIdx = 2;
    //   break;
    // }
    // 
    // // Currently, the load/store offset must be 0 to be considered for this
    // // peephole optimisation.
    // if (!isa<ConstantSDNode>(N->getOperand(OffsetOpIdx)) ||
    //     N->getConstantOperandVal(OffsetOpIdx) != 0)
    //   continue;
    // 
    // SDValue Base = N->getOperand(BaseOpIdx);
    // 
    // // If the base is an ADDI, we can merge it in to the load/store.
    // if (!Base.isMachineOpcode() || Base.getMachineOpcode() != RX::ADDI)
    //   continue;
    // 
    // SDValue ImmOperand = Base.getOperand(1);
    // 
    // if (auto Const = dyn_cast<ConstantSDNode>(ImmOperand)) {
    //   ImmOperand = CurDAG->getTargetConstant(
    //       Const->getSExtValue(), SDLoc(ImmOperand), ImmOperand.getValueType());
    // } else if (auto GA = dyn_cast<GlobalAddressSDNode>(ImmOperand)) {
    //   ImmOperand = CurDAG->getTargetGlobalAddress(
    //       GA->getGlobal(), SDLoc(ImmOperand), ImmOperand.getValueType(),
    //       GA->getOffset(), GA->getTargetFlags());
    // } else {
    //   continue;
    // }
    // 
    // LLVM_DEBUG(dbgs() << "Folding add-immediate into mem-op:\nBase:    ");
    // LLVM_DEBUG(Base->dump(CurDAG));
    // LLVM_DEBUG(dbgs() << "\nN: ");
    // LLVM_DEBUG(N->dump(CurDAG));
    // LLVM_DEBUG(dbgs() << "\n");
    // 
    // // Modify the offset operand of the load/store.
    // if (BaseOpIdx == 0) // Load
    //   CurDAG->UpdateNodeOperands(N, Base.getOperand(0), ImmOperand,
    //                              N->getOperand(2));
    // else // Store
    //   CurDAG->UpdateNodeOperands(N, N->getOperand(0), Base.getOperand(0),
    //                              ImmOperand, N->getOperand(3));
    // 
    // // The add-immediate may now be dead, in which case remove it.
    // if (Base.getNode()->use_empty())
    //   CurDAG->RemoveDeadNode(Base.getNode());
  }
}

// Remove redundant BuildPairF64+SplitF64 pairs. i.e. cases where an f64 is
// built of two i32 values, only to be split apart again. This must be done
// here as a peephole optimisation as the DAG has not been fully legalized at
// the point BuildPairF64/SplitF64 nodes are created in RXISelLowering, so
// some nodes would not yet have been replaced with libcalls.
void RXDAGToDAGISel::doPeepholeBuildPairF64SplitF64() {
  SelectionDAG::allnodes_iterator Position(CurDAG->getRoot().getNode());
  ++Position;

  while (Position != CurDAG->allnodes_begin()) {
    SDNode *N = &*--Position;
  }
  CurDAG->RemoveDeadNodes();
}

// This pass converts a legalized DAG into a RX-specific DAG, ready
// for instruction scheduling.
FunctionPass *llvm::createRXISelDag(RXTargetMachine &TM) {
  return new RXDAGToDAGISel(TM);
}
